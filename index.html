<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üéµ Èü≥ÂáÜËÆ≠ÁªÉÂ§ßÂ∏à</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        .glass-btn {
            background: rgba(99, 102, 241, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.3);
            transition: all 0.3s ease;
        }

        .glass-btn:hover {
            background: rgba(99, 102, 241, 0.3);
            transform: scale(1.05);
        }

        .glass-btn.active {
            background: rgba(139, 92, 246, 0.4);
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }

        .record-btn {
            transition: all 0.3s ease;
        }

        .record-btn.recording {
            animation: record-pulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(239, 68, 68, 0.6);
        }

        @keyframes record-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .result-overlay {
            animation: fade-in 0.3s ease-out;
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .stat-card {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #gameCanvas {
            display: block;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-[#1E1E2F] via-[#2B2B3D] to-[#1E1E2F] min-h-screen flex flex-col">

    <canvas id="gameCanvas" class="fixed inset-0"></canvas>

    <!-- È°∂ÈÉ®ÊåâÈíÆÂå∫Âüü -->
    <div class="fixed top-0 left-0 right-0 z-20 p-4">
        <div class="max-w-2xl mx-auto">
            <!-- Êí≠ÊîæÁõÆÊ†áÈü≥ÊåâÈíÆ -->
            <div class="flex justify-center mb-4">
                <button id="playTargetBtn" class="glass-btn px-6 py-3 rounded-full text-white font-bold flex items-center gap-2 shadow-lg">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    <span>Êí≠ÊîæÁõÆÊ†áÈü≥</span>
                </button>
            </div>

            <!-- Èü≥Ëâ≤ÈÄâÊã©ÊåâÈíÆ -->
            <div class="flex justify-center gap-2">
                <button class="glass-btn active w-12 h-12 rounded-full flex items-center justify-center text-white text-xl shadow-md" data-sound="triangle" title="‰∏âËßíÊ≥¢">
                    üéπ
                </button>
                <button class="glass-btn w-12 h-12 rounded-full flex items-center justify-center text-white text-xl shadow-md" data-sound="sine" title="Ê≠£Âº¶Ê≥¢">
                    üéµ
                </button>
                <button class="glass-btn w-12 h-12 rounded-full flex items-center justify-center text-white text-xl shadow-md" data-sound="piano" title="Èí¢Áê¥">
                    üéº
                </button>
                <button class="glass-btn w-12 h-12 rounded-full flex items-center justify-center text-white text-xl shadow-md" data-sound="voice" title="‰∫∫Â£∞">
                    üé§
                </button>
            </div>

            <!-- ÁõÆÊ†áÈü≥ÊòæÁ§∫ -->
            <div class="text-center mt-3">
                <p id="targetNoteDisplay" class="text-white/60 text-sm">ÁÇπÂáªÊí≠ÊîæÁõÆÊ†áÈü≥ÂºÄÂßãËÆ≠ÁªÉ</p>
            </div>
        </div>
    </div>

    <!-- Â∫ïÈÉ®ÂΩïÈü≥ÊåâÈíÆ -->
    <div class="fixed bottom-0 left-0 right-0 z-20 p-6 pb-8">
        <div class="flex flex-col items-center gap-2">
            <button id="recordBtn" class="record-btn w-24 h-24 rounded-full bg-gradient-to-br from-red-500 to-red-600 shadow-xl flex items-center justify-center text-white">
                <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="6"/>
                </svg>
            </button>
            <p id="recordStatus" class="text-white/60 text-sm">Êåâ‰ΩèÂèëÂ£∞</p>
        </div>
    </div>

    <!-- ÁªìÊûúÂºπÁ™ó -->
    <div id="resultOverlay" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 hidden result-overlay">
        <div class="bg-[#2B2B3D]/95 rounded-3xl p-8 shadow-2xl border border-white/10 max-w-sm mx-4">
            <div id="resultIcon" class="text-7xl mb-4 text-center"></div>
            <h2 id="resultTitle" class="text-3xl font-bold text-center mb-2 text-white"></h2>
            <p id="resultDetail" class="text-white/60 text-center mb-6"></p>

            <!-- ÁªüËÆ°Êï∞ÊçÆ -->
            <div class="grid grid-cols-3 gap-3 mb-6">
                <div class="stat-card rounded-xl p-3 text-center">
                    <div id="statPerfect" class="text-2xl font-bold text-emerald-400">0</div>
                    <div class="text-xs text-white/50 mt-1">ÂÆåÁæé</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div id="statClose" class="text-2xl font-bold text-amber-400">0</div>
                    <div class="text-xs text-white/50 mt-1">Êé•Ëøë</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div id="statOff" class="text-2xl font-bold text-red-400">0</div>
                    <div class="text-xs text-white/50 mt-1">ÂÅèÁ¶ª</div>
                </div>
            </div>

            <button id="closeResult" class="w-full py-3 bg-gradient-to-r from-[#6366F1] to-[#8B5CF6] text-white font-bold rounded-xl shadow-lg">
                ÂÜçÊù•‰∏ÄÂ±Ä
            </button>
        </div>
    </div>

    <script>
        const NOTE_FREQUENCIES = {
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
            'C6': 1046.50
        };

        let audioContext = null;
        let analyser = null;
        let mediaStream = null;
        let currentTargetFrequency = null;
        let currentTargetNote = null;
        let selectedSoundType = 'triangle';
        let isRecording = false;
        let isDemoPlaying = false;

        const arrows = [];
        const landedPoints = [];
        const PITCH_SMOOTHING = 3;
        let pitchHistory = [];
        let lastArrowTime = 0;
        const ARROW_INTERVAL = 120;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let target = {
            x: 0,
            y: 0,
            radius: 0,
            pulsePhase: 0,
            waveRings: []
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            target.x = window.innerWidth / 2;
            target.y = window.innerHeight * 0.35;
            target.radius = Math.min(200, window.innerWidth * 0.35, window.innerHeight * 0.25);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function getRandomNote() {
            const noteNames = Object.keys(NOTE_FREQUENCIES);
            const randomIndex = Math.floor(Math.random() * noteNames.length);
            const noteName = noteNames[randomIndex];
            return { name: noteName, frequency: NOTE_FREQUENCIES[noteName] };
        }

        async function playDemoTone() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                const note = getRandomNote();
                currentTargetNote = note.name;
                currentTargetFrequency = note.frequency;

                document.getElementById('targetNoteDisplay').textContent = `ÁõÆÊ†áÈü≥: ${note.name} (${note.frequency.toFixed(0)} Hz)`;

                isDemoPlaying = true;
                target.waveRings = [];

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const analyserNode = audioContext.createAnalyser();

                oscillator.type = selectedSoundType === 'triangle' || selectedSoundType === 'piano' ? 'triangle' : 'sine';
                oscillator.frequency.value = currentTargetFrequency;
                oscillator.connect(gainNode);
                gainNode.connect(analyserNode);
                analyserNode.connect(audioContext.destination);

                analyserNode.fftSize = 256;

                const dataArray = new Uint8Array(analyserNode.frequencyBinCount);

                const updateWave = () => {
                    if (!isDemoPlaying) return;
                    analyserNode.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                    const amplitude = (average / 255) * target.radius * 0.5;

                    if (amplitude > 5) {
                        target.waveRings.push({
                            radius: target.radius,
                            amplitude: amplitude,
                            opacity: 0.6,
                            phase: 0
                        });
                    }

                    requestAnimationFrame(updateWave);
                };
                updateWave();

                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.35, now + 0.05);
                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.9);
                gainNode.gain.linearRampToValueAtTime(0, now + 1);

                oscillator.start(now);
                oscillator.stop(now + 1);

                oscillator.onended = () => {
                    isDemoPlaying = false;
                };

            } catch (error) {
                console.error('Play error:', error);
            }
        }

        function autocorrelate(buffer, sampleRate) {
            const SIZE = buffer.length;
            const MAX_SAMPLES = Math.floor(SIZE / 2);
            let bestOffset = -1;
            let bestCorrelation = 0;
            let rms = 0;

            for (let i = 0; i < SIZE; i++) rms += buffer[i] * buffer[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < 0.01) return -1;

            let lastCorrelation = 1;
            let foundGoodCorrelation = false;

            for (let offset = 0; offset < MAX_SAMPLES; offset++) {
                let correlation = 0;
                for (let i = 0; i < MAX_SAMPLES; i++) {
                    correlation += Math.abs(buffer[i] - buffer[i + offset]);
                }
                correlation = 1 - (correlation / MAX_SAMPLES);

                if (correlation > 0.9 && correlation > lastCorrelation) {
                    foundGoodCorrelation = true;
                    if (correlation > bestCorrelation) {
                        bestCorrelation = correlation;
                        bestOffset = offset;
                    }
                } else if (foundGoodCorrelation) {
                    return sampleRate / bestOffset;
                }
                lastCorrelation = correlation;
            }

            if (bestCorrelation > 0.01) return sampleRate / bestOffset;
            return -1;
        }

        function detectPitch(buffer) {
            const sampleRate = audioContext.sampleRate;
            const frequency = autocorrelate(buffer, sampleRate);
            if (frequency === -1 || frequency < 80 || frequency > 1200) return null;
            return frequency;
        }

        function calculateCentsDiff(userFreq, targetFreq) {
            return Math.round(1200 * Math.log2(userFreq / targetFreq));
        }

        function smoothPitch(pitch) {
            pitchHistory.push(pitch);
            if (pitchHistory.length > PITCH_SMOOTHING) {
                pitchHistory.shift();
            }
            const sum = pitchHistory.reduce((a, b) => a + b, 0);
            return sum / pitchHistory.length;
        }

        function getCentsColor(cents) {
            if (Math.abs(cents) <= 10) return '#10B981';
            if (Math.abs(cents) <= 30) return '#F59E0B';
            return '#EF4444';
        }

        function getCentsCategory(cents) {
            if (Math.abs(cents) <= 10) return 'perfect';
            if (Math.abs(cents) <= 30) return 'close';
            return 'off';
        }

        class Arrow {
            constructor(startX, startY, targetX, targetY, cents) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.cents = cents;
                this.color = getCentsColor(cents);
                this.progress = 0;
                this.speed = 0.04;
                this.landed = false;
                this.trail = [];
            }

            update() {
                if (this.landed) return;

                this.progress += this.speed;
                this.trail.push({ x: this.x, y: this.y, progress: this.progress });
                if (this.trail.length > 12) this.trail.shift();

                this.x += (this.targetX - this.x) * this.speed;
                this.y += (this.targetY - this.y) * this.speed;

                if (this.progress >= 1 || Math.abs(this.x - this.targetX) < 3) {
                    this.landed = true;
                    this.x = this.targetX;
                    this.y = this.targetY;
                    landedPoints.push({
                        x: this.x,
                        y: this.y,
                        cents: this.cents,
                        color: this.color,
                        category: getCentsCategory(this.cents),
                        scale: 0
                    });
                }
            }

            draw(ctx) {
                if (this.landed) return;

                ctx.save();

                if (this.trail.length > 1) {
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = i / this.trail.length;
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);

                        const gradient = ctx.createLinearGradient(
                            this.trail[i - 1].x, this.trail[i - 1].y,
                            this.trail[i].x, this.trail[i].y
                        );
                        gradient.addColorStop(0, this.color + '00');
                        gradient.addColorStop(1, this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2 * alpha;
                        ctx.stroke();
                    }
                }

                ctx.translate(this.x, this.y);
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                ctx.rotate(angle);

                ctx.fillStyle = '#92400e';
                ctx.fillRect(-25, -2, 25, 4);

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-6, -4);
                ctx.lineTo(-6, 4);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#F59E0B';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(-27, -2 + i * 2, 5, 1);
                }

                ctx.restore();
            }
        }

        async function startRecording() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                const source = audioContext.createMediaStreamSource(mediaStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                isRecording = true;
                pitchHistory = [];
                lastArrowTime = Date.now();

                detectPitchLoop();

            } catch (error) {
                console.error('Microphone error:', error);
                alert('Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£éÔºåËØ∑Ê£ÄÊü•ÊùÉÈôêËÆæÁΩÆ');
            }
        }

        function stopRecording() {
            isRecording = false;
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            showResult();
        }

        function detectPitchLoop() {
            if (!isRecording) return;

            const bufferLength = analyser.fftSize;
            const buffer = new Float32Array(bufferLength);
            analyser.getFloatTimeDomainData(buffer);

            const pitch = detectPitch(buffer);
            if (pitch && currentTargetFrequency) {
                const smoothedPitch = smoothPitch(pitch);
                const centsDiff = calculateCentsDiff(smoothedPitch, currentTargetFrequency);

                const now = Date.now();
                if (now - lastArrowTime >= ARROW_INTERVAL) {
                    const startX = window.innerWidth / 2;
                    const startY = window.innerHeight - 150;
                    const targetY = target.y + (centsDiff * 3.5);
                    const angle = (Math.random() - 0.5) * 0.4;

                    const arrow = new Arrow(
                        startX + Math.cos(angle) * 30,
                        startY + Math.sin(angle) * 30,
                        target.x + (Math.random() - 0.5) * target.radius * 0.5,
                        targetY,
                        centsDiff
                    );
                    arrows.push(arrow);
                    lastArrowTime = now;
                }

                const rms = Math.sqrt(buffer.reduce((sum, val) => sum + val * val, 0) / buffer.length);
                if (rms > 0.02) {
                    const amplitude = Math.min(rms * 15, target.radius * 0.6);
                    target.waveRings.push({
                        radius: target.radius,
                        amplitude: amplitude,
                        opacity: 0.5,
                        phase: 0
                    });
                }
            }

            requestAnimationFrame(detectPitchLoop);
        }

        function showResult() {
            if (landedPoints.length === 0) {
                document.getElementById('resultIcon').textContent = 'üò∂';
                document.getElementById('resultTitle').textContent = 'Êú™Ê£ÄÊµãÂà∞Â£∞Èü≥';
                document.getElementById('resultTitle').className = 'text-3xl font-bold text-center mb-2 text-white/60';
                document.getElementById('resultDetail').textContent = 'ËØ∑Á°Æ‰øùÂ∑≤Êí≠ÊîæÁõÆÊ†áÈü≥Âπ∂ÂèëÂá∫Â£∞Èü≥';
            } else {
                const avgCents = landedPoints.reduce((sum, p) => sum + p.cents, 0) / landedPoints.length;
                const perfect = landedPoints.filter(p => p.category === 'perfect').length;
                const close = landedPoints.filter(p => p.category === 'close').length;
                const off = landedPoints.filter(p => p.category === 'off').length;

                if (Math.abs(avgCents) <= 12) {
                    document.getElementById('resultIcon').textContent = 'üéØ';
                    document.getElementById('resultTitle').textContent = 'ÂÆåÁæéÂëΩ‰∏≠ÔºÅ';
                    document.getElementById('resultTitle').className = 'text-3xl font-bold text-center mb-2 text-emerald-400';
                } else if (Math.abs(avgCents) <= 35) {
                    document.getElementById('resultIcon').textContent = avgCents > 0 ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
                    document.getElementById('resultTitle').textContent = avgCents > 0 ? 'Á®çÂæÆÂÅèÈ´ò' : 'Á®çÂæÆÂÅè‰Ωé';
                    document.getElementById('resultTitle').className = 'text-3xl font-bold text-center mb-2 text-amber-400';
                } else {
                    document.getElementById('resultIcon').textContent = avgCents > 0 ? '‚¨ÜÔ∏è‚¨ÜÔ∏è' : '‚¨áÔ∏è‚¨áÔ∏è';
                    document.getElementById('resultTitle').textContent = avgCents > 0 ? 'ÂÅèÈ´òÂæàÂ§ö' : 'ÂÅè‰ΩéÂæàÂ§ö';
                    document.getElementById('resultTitle').className = 'text-3xl font-bold text-center mb-2 text-red-400';
                }

                document.getElementById('resultDetail').textContent = `Âπ≥ÂùáÂÅèÂ∑Æ ${Math.abs(avgCents).toFixed(1)}¬¢ | ÂèëÂ∞Ñ ${landedPoints.length} ÊîØÁÆ≠`;
                document.getElementById('statPerfect').textContent = perfect;
                document.getElementById('statClose').textContent = close;
                document.getElementById('statOff').textContent = off;
            }

            document.getElementById('resultOverlay').classList.remove('hidden');
        }

        function drawTarget() {
            const pulse = isDemoPlaying ? Math.sin(Date.now() / 100) * 6 : 0;
            const baseRadius = target.radius + pulse;

            ctx.save();
            ctx.translate(target.x, target.y);

            for (let i = 5; i > 0; i--) {
                const r = baseRadius * (i / 5);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r);

                if (i === 1) {
                    gradient.addColorStop(0, 'rgba(239, 68, 68, 0.8)');
                    gradient.addColorStop(0.6, 'rgba(239, 68, 68, 0.4)');
                    gradient.addColorStop(1, 'rgba(239, 68, 68, 0.1)');
                } else {
                    gradient.addColorStop(0, 'rgba(99, 102, 241, 0.15)');
                    gradient.addColorStop(0.7, 'rgba(139, 92, 246, 0.1)');
                    gradient.addColorStop(1, 'rgba(139, 92, 246, 0.05)');
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = i === 1 ? '#EF4444' : 'rgba(99, 102, 241, 0.4)';
                ctx.lineWidth = i === 1 ? 2.5 : 1.5;
                ctx.stroke();
            }

            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();

            if (isDemoPlaying) {
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();

            for (const point of landedPoints) {
                if (point.scale < 1) {
                    point.scale += 0.1;
                    if (point.scale > 1) point.scale = 1;
                }

                const size = 8 * point.scale;
                const gradient = ctx.createRadialGradient(
                    point.x, point.y, 0,
                    point.x, point.y, size
                );
                gradient.addColorStop(0, point.color);
                gradient.addColorStop(0.5, point.color + '80');
                gradient.addColorStop(1, point.color + '20');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4 * point.scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWaveRings() {
            for (let i = target.waveRings.length - 1; i >= 0; i--) {
                const ring = target.waveRings[i];
                ring.phase += 0.03;
                ring.opacity -= 0.008;

                if (ring.opacity <= 0) {
                    target.waveRings.splice(i, 1);
                    continue;
                }

                const currentRadius = ring.radius + ring.amplitude * Math.sin(ring.phase);
                const gradient = ctx.createRadialGradient(
                    target.x, target.y, currentRadius - 10,
                    target.x, target.y, currentRadius + 10
                );
                gradient.addColorStop(0, `rgba(99, 102, 241, 0)`);
                gradient.addColorStop(0.5, `rgba(139, 92, 246, ${ring.opacity * 0.6})`);
                gradient.addColorStop(1, `rgba(99, 102, 241, 0)`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(target.x, target.y, currentRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawWaveRings();
            drawTarget();

            for (let i = arrows.length - 1; i >= 0; i--) {
                arrows[i].update();
                arrows[i].draw(ctx);
                if (arrows[i].landed) {
                    arrows.splice(i, 1);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        const recordBtn = document.getElementById('recordBtn');
        const recordStatus = document.getElementById('recordStatus');

        recordBtn.addEventListener('mousedown', startRecording);
        recordBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startRecording();
        });

        const stopRecordingHandler = () => {
            if (isRecording) {
                stopRecording();
            }
        };

        recordBtn.addEventListener('mouseup', stopRecordingHandler);
        recordBtn.addEventListener('touchend', stopRecordingHandler);
        recordBtn.addEventListener('mouseleave', stopRecordingHandler);

        const updateRecordButton = () => {
            if (isRecording) {
                recordBtn.classList.add('recording');
                recordStatus.textContent = 'ÂΩïÈü≥‰∏≠... ÊùæÂºÄÁªìÊùü';
            } else {
                recordBtn.classList.remove('recording');
                recordStatus.textContent = 'Êåâ‰ΩèÂèëÂ£∞';
            }
        };

        recordBtn.addEventListener('mousedown', () => {
            if (!currentTargetFrequency) {
                alert('ËØ∑ÂÖàÊí≠ÊîæÁõÆÊ†áÈü≥ÔºÅ');
                return;
            }
            updateRecordButton();
        });

        recordBtn.addEventListener('touchstart', () => {
            if (!currentTargetFrequency) {
                alert('ËØ∑ÂÖàÊí≠ÊîæÁõÆÊ†áÈü≥ÔºÅ');
                return;
            }
            updateRecordButton();
        });

        document.addEventListener('mouseup', () => {
            if (isRecording) updateRecordButton();
        });

        document.addEventListener('touchend', () => {
            if (isRecording) updateRecordButton();
        });

        document.getElementById('playTargetBtn').addEventListener('click', playDemoTone);

        document.querySelectorAll('.glass-btn[data-sound]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.glass-btn[data-sound]').forEach(b => {
                    b.classList.remove('active');
                });
                btn.classList.add('active');
                selectedSoundType = btn.dataset.sound;
            });
        });

        document.getElementById('closeResult').addEventListener('click', () => {
            document.getElementById('resultOverlay').classList.add('hidden');
            landedPoints.length = 0;
            arrows.length = 0;
            currentTargetFrequency = null;
            target.waveRings = [];
            document.getElementById('targetNoteDisplay').textContent = 'ÁÇπÂáªÊí≠ÊîæÁõÆÊ†áÈü≥ÂºÄÂßãËÆ≠ÁªÉ';
        });

        resizeCanvas();
        gameLoop();

        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        document.addEventListener('click', async () => {
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
        }, { once: true });
    </script>
</body>
</html>
