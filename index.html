æ›´æ–°ä¸ºå®æ—¶å°„å‡»ç‰ˆ
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>ğŸ¹ éŸ³é«˜å°„é¶ - å®æ—¶å°„å‡»</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            touch-action: manipulation;
        }
        h1, h2, h3 {
            font-family: 'Nunito', sans-serif;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 30px rgba(16, 185, 129, 0.6); }
            50% { box-shadow: 0 0 60px rgba(16, 185, 129, 0.9), 0 0 90px rgba(16, 185, 129, 0.4); }
        }

        @keyframes recording-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }
            50% {
                box-shadow: 0 0 0 20px rgba(239, 68, 68, 0);
            }
        }

        .record-btn.recording {
            animation: recording-pulse 1.5s ease-out infinite;
            background: linear-gradient(to bottom, #dc2626, #b91c1c);
        }

        .record-btn.recording:active {
            animation: none;
        }

        .target-hit {
            animation: pulse-glow 0.6s ease-out;
        }

        .sound-btn.active {
            background: linear-gradient(135deg, #6366F1 0%, #8B5CF6 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .mobile-touch-btn {
            min-height: 48px;
            min-width: 48px;
        }

        .record-btn {
            min-height: 120px;
        }

        button {
            touch-action: manipulation;
        }

        #debugInfo {
            font-size: 10px;
            color: #64748b;
            word-break: break-all;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 min-h-screen flex flex-col items-center p-3 pb-6 text-white">

    <header class="w-full max-w-lg mb-3 text-center">
        <h1 class="text-3xl font-extrabold bg-gradient-to-r from-amber-400 via-orange-500 to-red-500 bg-clip-text text-transparent mb-1">
            ğŸ¹ éŸ³é«˜å°„é¶
        </h1>
        <p class="text-slate-400 text-xs">å®æ—¶å°„å‡»ç‰ˆ - æŒ‰ä½å½•éŸ³ï¼Œç®­éšéŸ³é«˜é£è¡Œ</p>
    </header>

    <div class="w-full max-w-lg bg-slate-800/50 backdrop-blur rounded-2xl shadow-xl p-3 mb-3 border border-slate-700 relative">
        <canvas id="gameCanvas" class="w-full rounded-xl" style="height: 280px;"></canvas>
    </div>

    <div class="w-full max-w-lg bg-slate-800/50 backdrop-blur rounded-2xl shadow-xl p-4 mb-3 border border-slate-700">
        <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-2">
                <div class="w-10 h-10 bg-gradient-to-br from-amber-400 to-orange-500 rounded-full flex items-center justify-center flex-shrink-0">
                    <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                    </svg>
                </div>
                <div class="min-w-0">
                    <p class="text-sm font-semibold text-slate-200">ç›®æ ‡éŸ³</p>
                    <p id="targetNoteDisplay" class="text-xs text-slate-400 truncate">ç‚¹å‡»æ’­æ”¾</p>
                </div>
            </div>
            <button id="playDemoBtn" class="mobile-touch-btn px-4 py-2 bg-gradient-to-r from-indigo-600 to-violet-600 active:scale-95 text-white font-bold rounded-xl transition-all shadow-md flex items-center gap-1 flex-shrink-0">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                æ’­æ”¾
            </button>
        </div>

        <div class="grid grid-cols-4 gap-2">
            <button class="sound-btn active mobile-touch-btn px-2 py-2 rounded-xl text-center font-semibold transition-all flex flex-col items-center gap-1 text-xs" data-sound="triangle">
                <span class="text-xl">ğŸ¹</span><span>ä¸‰è§’</span>
            </button>
            <button class="sound-btn mobile-touch-btn px-2 py-2 rounded-xl text-center font-semibold text-slate-300 transition-all flex flex-col items-center gap-1 text-xs bg-slate-700/50" data-sound="sine">
                <span class="text-xl">ğŸµ</span><span>æ­£å¼¦</span>
            </button>
            <button class="sound-btn mobile-touch-btn px-2 py-2 rounded-xl text-center font-semibold text-slate-300 transition-all flex flex-col items-center gap-1 text-xs bg-slate-700/50" data-sound="piano">
                <span class="text-xl">ğŸ¼</span><span>é’¢ç´</span>
            </button>
            <button class="sound-btn mobile-touch-btn px-2 py-2 rounded-xl text-center font-semibold text-slate-300 transition-all flex flex-col items-center gap-1 text-xs bg-slate-700/50" data-sound="voice">
                <span class="text-xl">ğŸ¤</span><span>äººå£°</span>
            </button>
        </div>
    </div>

    <div class="w-full max-w-lg bg-slate-800/50 backdrop-blur rounded-2xl shadow-xl p-4 mb-3 border border-slate-700">
        <h3 class="text-sm font-bold text-slate-200 mb-3 flex items-center gap-2">
            <svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
            </svg>
            å°„å‡»æ§åˆ¶
        </h3>

        <button id="recordBtn" class="record-btn w-full bg-gradient-to-br from-red-600 to-red-700 active:from-red-700 active:to-red-800 active:scale-95 text-white text-base font-bold rounded-2xl transition-all shadow-lg flex flex-col items-center justify-center gap-2 select-none mb-2">
            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>
            <span>æŒ‰ä½å°„å‡»</span>
        </button>

        <p id="recordingStatus" class="text-center text-sm text-slate-400 min-h-[20px]">
            å…ˆæ’­æ”¾ç›®æ ‡éŸ³ï¼Œç„¶åæŒ‰ä½å½•éŸ³å¼€å§‹å°„å‡»
        </p>

        <p id="debugInfo" class="text-center text-xs text-slate-500 mt-1 hidden"></p>
    </div>

    <div class="w-full max-w-lg text-center pb-2">
        <p class="text-xs text-slate-500">
            ğŸ’¡ æ’­æ”¾ç›®æ ‡éŸ³ â†’ æŒ‰ä½å°„å‡» â†’ è°ƒæ•´éŸ³é«˜æ§åˆ¶æ–¹å‘ â†’ æ¾å¼€å‘½ä¸­
        </p>
    </div>

    <div id="resultOverlay" class="fixed inset-0 flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-500 z-50">
        <div class="text-center bg-slate-900/95 rounded-2xl p-6 shadow-2xl border border-slate-600 mx-4 max-w-sm">
            <div id="resultIcon" class="text-5xl mb-3"></div>
            <p id="resultText" class="text-2xl font-bold mb-1"></p>
            <p id="resultDetail" class="text-sm text-slate-400"></p>
        </div>
    </div>

    <script>
        const NOTE_FREQUENCIES = {
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
            'C6': 1046.50
        };

        let currentTargetFrequency = null;
        let currentTargetNote = null;
        let selectedSoundType = 'triangle';
        let audioContext = null;
        let analyser = null;
        let mediaStream = null;
        let isRecording = false;
        let isFlying = false;

        let arrow = {
            x: 0,
            y: 0,
            targetX: 0,
            targetY: 0,
            trail: [],
            speed: 0,
            color: '#f59e0b',
            isHit: false
        };

        let pitchHistory = [];
        const PITCH_SMOOTHING = 5;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function debugLog(message) {
            const debugEl = document.getElementById('debugInfo');
            debugEl.textContent = message;
            debugEl.classList.remove('hidden');
            console.log('[Debug]', message);
        }

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }

        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        function drawTarget(isHit = false) {
            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;
            const centerX = width * 0.75;
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);

            // å‘å°„å°
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, centerY - 50, 60, 100);
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, centerY - 50, 60, 100);

            // å¼“
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(30, centerY, 40, -Math.PI / 2, Math.PI / 2);
            ctx.stroke();

            // é¶å­
            const targetRadius = 100;
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, targetRadius);
            gradient.addColorStop(0, isHit ? 'rgba(16, 185, 129, 0.3)' : '#FEF3C7');
            gradient.addColorStop(0.7, '#FDE68A');
            gradient.addColorStop(1, '#FCD34D');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, targetRadius, 0, Math.PI * 2);
            ctx.fill();

            for (let i = 5; i > 0; i--) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, targetRadius * (i / 5), 0, Math.PI * 2);
                ctx.strokeStyle = i === 1 ? '#EF4444' : '#F59E0B';
                ctx.lineWidth = i === 1 ? 2 : 1.5;
                ctx.stroke();
            }

            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 12, 0, Math.PI * 2);
            ctx.fill();

            if (isHit) {
                ctx.strokeStyle = '#10B981';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                ctx.stroke();
            }

            return { centerX, centerY, targetRadius };
        }

        function drawArrow() {
            if (arrow.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(arrow.trail[0].x, arrow.trail[0].y);

                for (let i = 1; i < arrow.trail.length; i++) {
                    ctx.lineTo(arrow.trail[i].x, arrow.trail[i].y);
                }

                const gradient = ctx.createLinearGradient(
                    arrow.trail[0].x, arrow.trail[0].y,
                    arrow.x, arrow.y
                );
                gradient.addColorStop(0, 'rgba(245, 158, 11, 0)');
                gradient.addColorStop(1, arrow.color);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            const arrowLength = 50;
            const arrowHead = 12;

            ctx.save();
            ctx.translate(arrow.x, arrow.y);

            ctx.fillStyle = '#92400e';
            ctx.fillRect(-arrowLength, -2, arrowLength, 3);

            ctx.fillStyle = arrow.color;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowHead, -5);
            ctx.lineTo(-arrowHead, 5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#f59e0b';
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(-arrowLength - 4, -3 + i * 3, 6, 1.5);
            }

            ctx.restore();
        }

        function getRandomNote() {
            const noteNames = Object.keys(NOTE_FREQUENCIES);
            const randomIndex = Math.floor(Math.random() * noteNames.length);
            const noteName = noteNames[randomIndex];
            return { name: noteName, frequency: NOTE_FREQUENCIES[noteName] };
        }

        async function playDemoTone() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    debugLog('AudioContext åˆ›å»ºæˆåŠŸ');
                }

                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    debugLog('AudioContext å·²æ¢å¤');
                }

                const note = getRandomNote();
                currentTargetNote = note.name;
                currentTargetFrequency = note.frequency;

                document.getElementById('targetNoteDisplay').textContent = `${note.name} (${note.frequency.toFixed(0)} Hz)`;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = selectedSoundType === 'triangle' || selectedSoundType === 'piano' ? 'triangle' : 'sine';
                oscillator.frequency.value = currentTargetFrequency;
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.4, now + 0.05);
                gainNode.gain.linearRampToValueAtTime(0.4, now + 1.5);
                gainNode.gain.linearRampToValueAtTime(0, now + 2);

                oscillator.start(now);
                oscillator.stop(now + 2);

            } catch (error) {
                debugLog('æ’­æ”¾é”™è¯¯: ' + error.message);
                console.error('Play error:', error);
            }
        }

        function autocorrelate(buffer, sampleRate) {
            const SIZE = buffer.length;
            const MAX_SAMPLES = Math.floor(SIZE / 2);
            let bestOffset = -1;
            let bestCorrelation = 0;
            let rms = 0;

            for (let i = 0; i < SIZE; i++) rms += buffer[i] * buffer[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < 0.01) return -1;

            let lastCorrelation = 1;
            let foundGoodCorrelation = false;

            for (let offset = 0; offset < MAX_SAMPLES; offset++) {
                let correlation = 0;
                for (let i = 0; i < MAX_SAMPLES; i++) {
                    correlation += Math.abs(buffer[i] - buffer[i + offset]);
                }
                correlation = 1 - (correlation / MAX_SAMPLES);

                if (correlation > 0.9 && correlation > lastCorrelation) {
                    foundGoodCorrelation = true;
                    if (correlation > bestCorrelation) {
                        bestCorrelation = correlation;
                        bestOffset = offset;
                    }
                } else if (foundGoodCorrelation) {
                    return sampleRate / bestOffset;
                }
                lastCorrelation = correlation;
            }

            if (bestCorrelation > 0.01) return sampleRate / bestOffset;
            return -1;
        }

        function detectPitch(buffer) {
            const sampleRate = audioContext.sampleRate;
            const frequency = autocorrelate(buffer, sampleRate);
            if (frequency === -1 || frequency < 80 || frequency > 1200) return null;
            return frequency;
        }

        function calculateCentsDiff(userFreq, targetFreq) {
            return Math.round(1200 * Math.log2(userFreq / targetFreq));
        }

        function smoothPitch(pitch) {
            pitchHistory.push(pitch);
            if (pitchHistory.length > PITCH_SMOOTHING) {
                pitchHistory.shift();
            }
            const sum = pitchHistory.reduce((a, b) => a + b, 0);
            return sum / pitchHistory.length;
        }

        async function startRecording() {
            try {
                debugLog('è¯·æ±‚éº¦å…‹é£æƒé™...');

                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                debugLog('éº¦å…‹é£æƒé™å·²è·å–');

                const source = audioContext.createMediaStreamSource(mediaStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                isRecording = true;
                isFlying = true;
                pitchHistory = [];

                const width = canvas.getBoundingClientRect().width;
                const height = canvas.getBoundingClientRect().height;
                arrow.x = 60;
                arrow.y = height / 2;
                arrow.targetX = width * 0.72;
                arrow.targetY = height / 2;
                arrow.speed = (arrow.targetX - arrow.x) / 120;
                arrow.trail = [];
                arrow.color = '#f59e0b';
                arrow.isHit = false;

                detectPitchLoop();

            } catch (error) {
                debugLog('éº¦å…‹é£é”™è¯¯: ' + error.message);
                console.error('Microphone error:', error);

                const statusEl = document.getElementById('recordingStatus');
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    statusEl.textContent = 'âŒ è¯·å…è®¸éº¦å…‹é£æƒé™';
                } else if (error.name === 'NotFoundError') {
                    statusEl.textContent = 'âŒ æœªæ‰¾åˆ°éº¦å…‹é£';
                } else if (location.protocol !== 'https:' &&
                           location.hostname !== 'localhost' &&
                           location.hostname !== '127.0.0.1' &&
                           !location.hostname.startsWith('192.168.') &&
                           !location.hostname.startsWith('10.')) {
                    statusEl.textContent = 'âŒ éœ€è¦ HTTPS';
                } else {
                    statusEl.textContent = 'âŒ éº¦å…‹é£è®¿é—®å¤±è´¥';
                }

                throw error;
            }
        }

        function detectPitchLoop() {
            if (!isRecording) return;

            const bufferLength = analyser.fftSize;
            const buffer = new Float32Array(bufferLength);
            analyser.getFloatTimeDomainData(buffer);

            const pitch = detectPitch(buffer);
            if (pitch && currentTargetFrequency) {
                const smoothedPitch = smoothPitch(pitch);
                const centsDiff = calculateCentsDiff(smoothedPitch, currentTargetFrequency);

                const height = canvas.getBoundingClientRect().height;
                const centerY = height / 2;
                arrow.y = centerY + (centsDiff * 2.5);

                if (Math.abs(centsDiff) <= 10) {
                    arrow.color = '#10B981';
                } else if (Math.abs(centsDiff) <= 30) {
                    arrow.color = '#f59e0b';
                } else {
                    arrow.color = '#EF4444';
                }
            }

            setTimeout(detectPitchLoop, 80);
        }

        function stopRecording() {
            return new Promise((resolve) => {
                if (!isRecording) {
                    resolve();
                    return;
                }

                isRecording = false;

                setTimeout(() => {
                    isFlying = false;
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                    }

                    const height = canvas.getBoundingClientRect().height;
                    const centerY = height / 2;
                    const finalCents = Math.round((arrow.y - centerY) / 2.5);

                    showResult(finalCents);
                    debugLog('å‘½ä¸­: ' + finalCents + ' cents');
                    resolve();
                }, 300);
            });
        }

        function showResult(centsDiff) {
            const isHit = Math.abs(centsDiff) <= 10;

            if (isHit) {
                const targetEl = document.querySelector('canvas');
                targetEl.classList.add('target-hit');
                setTimeout(() => targetEl.classList.remove('target-hit'), 600);
            }

            const overlay = document.getElementById('resultOverlay');
            const icon = document.getElementById('resultIcon');
            const text = document.getElementById('resultText');
            const detail = document.getElementById('resultDetail');

            if (isHit) {
                icon.textContent = 'ğŸ¯';
                text.textContent = 'å®Œç¾å‘½ä¸­ï¼';
                text.className = 'text-2xl font-bold text-emerald-400';
                detail.textContent = `åå·® Â±${Math.abs(centsDiff)}Â¢`;
            } else if (Math.abs(centsDiff) <= 30) {
                icon.textContent = centsDiff > 0 ? 'â¬†ï¸' : 'â¬‡ï¸';
                text.textContent = centsDiff > 0 ? 'ç¨å¾®åé«˜' : 'ç¨å¾®åä½';
                text.className = 'text-2xl font-bold text-amber-400';
                detail.textContent = `åå·® ${Math.abs(centsDiff)}Â¢`;
            } else {
                icon.textContent = centsDiff > 0 ? 'â¬†ï¸â¬†ï¸' : 'â¬‡ï¸â¬‡ï¸';
                text.textContent = centsDiff > 0 ? 'åé«˜å¾ˆå¤š' : 'åä½å¾ˆå¤š';
                text.className = 'text-2xl font-bold text-red-400';
                detail.textContent = `åå·® ${Math.abs(centsDiff)}Â¢`;
            }

            overlay.style.opacity = '1';
            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 2000);
        }

        function gameLoop() {
            drawTarget(arrow.isHit);

            if (isFlying && arrow.x < arrow.targetX) {
                arrow.x += arrow.speed;
                arrow.trail.push({ x: arrow.x, y: arrow.y });
                if (arrow.trail.length > 25) {
                    arrow.trail.shift();
                }
                drawArrow();
            } else if (!isFlying && arrow.trail.length > 0) {
                drawArrow();
            }

            requestAnimationFrame(gameLoop);
        }

        const recordBtn = document.getElementById('recordBtn');
        const statusEl = document.getElementById('recordingStatus');

        async function handleStart(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!currentTargetFrequency) {
                statusEl.textContent = 'âš ï¸ è¯·å…ˆæ’­æ”¾ç›®æ ‡éŸ³';
                return;
            }

            if (isRecording) {
                debugLog('å·²åœ¨å½•éŸ³ä¸­');
                return;
            }

            try {
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }

                recordBtn.classList.add('recording');
                statusEl.textContent = 'ğŸ¹ ç®­åœ¨é£è¡Œ... è°ƒæ•´éŸ³é«˜æ§åˆ¶æ–¹å‘';

                await startRecording();

            } catch (error) {
                recordBtn.classList.remove('recording');
                debugLog('å¯åŠ¨å¤±è´¥: ' + error.message);
            }
        }

        async function handleStop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!isRecording) {
                debugLog('æœªåœ¨å½•éŸ³ä¸­');
                return;
            }

            try {
                recordBtn.classList.remove('recording');
                statusEl.textContent = 'ğŸ¯ å‘½ä¸­ç»“ç®—ä¸­...';

                await stopRecording();
                statusEl.textContent = 'âœ… å®Œæˆï¼å†è¯•ä¸€æ¬¡';

            } catch (error) {
                debugLog('åœæ­¢å¤±è´¥: ' + error.message);
                statusEl.textContent = 'âŒ å¤„ç†å¤±è´¥';
            }
        }

        recordBtn.addEventListener('touchstart', handleStart, { passive: false });
        recordBtn.addEventListener('touchend', handleStop, { passive: false });
        recordBtn.addEventListener('touchcancel', async (e) => {
            e.preventDefault();
            e.stopPropagation();

            if (isRecording) {
                isRecording = false;
                isFlying = false;
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
                recordBtn.classList.remove('recording');
                debugLog('å½•éŸ³å·²å–æ¶ˆ');
            }
        }, { passive: false });

        recordBtn.addEventListener('mousedown', handleStart);
        recordBtn.addEventListener('mouseup', handleStop);
        recordBtn.addEventListener('mouseleave', async () => {
            if (isRecording) {
                isRecording = false;
                isFlying = false;
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
                recordBtn.classList.remove('recording');
                debugLog('å½•éŸ³å·²å–æ¶ˆ');
            }
        });

        recordBtn.addEventListener('contextmenu', (e) => e.preventDefault());

        document.getElementById('playDemoBtn').addEventListener('click', () => {
            playDemoTone();
        });

        document.querySelectorAll('.sound-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.sound-btn').forEach(b => {
                    b.classList.remove('active');
                    b.classList.add('bg-slate-700/50', 'text-slate-300');
                });

                const targetBtn = e.currentTarget;
                targetBtn.classList.add('active');
                targetBtn.classList.remove('bg-slate-700/50', 'text-slate-300');
                selectedSoundType = targetBtn.dataset.sound;
            });
        });

        resizeCanvas();
        gameLoop();

        if (location.protocol !== 'https:' &&
            location.hostname !== 'localhost' &&
            location.hostname !== '127.0.0.1' &&
            !location.hostname.startsWith('192.168.') &&
            !location.hostname.startsWith('10.')) {
            debugLog('è­¦å‘Š: éœ€è¦ HTTPS è®¿é—®éº¦å…‹é£');
        }

        const initAudio = async () => {
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
                debugLog('AudioContext å·²åˆå§‹åŒ–');
            }
        };

        document.addEventListener('touchstart', initAudio, { once: true });
        document.addEventListener('click', initAudio, { once: true });

        debugLog('å®æ—¶å°„å‡»ç‰ˆå·²å°±ç»ª');
    </script>
</body>
</html>
